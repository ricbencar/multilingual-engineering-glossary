"""
====================================================================================================
  SCRIPT NAME: High-Performance Multilingual PDF Table Generator (Stage 2 - Tabular)
====================================================================================================

  --------------------------------------------------------------------------------------------------
  1. OVERVIEW
  --------------------------------------------------------------------------------------------------
  This script is the "Stage 2" processor for TABULAR output. It takes the 'glossary.xlsx' file 
  generated by Stage 1 and compiles it into a professional, landscape-oriented PDF table ('table.pdf').

  Unlike standard PDF converters, this script uses a "Smart Font Engine" to dynamically swap 
  typefaces cell-by-cell. This ensures that a single row can display Arabic (Right-to-Left), 
  Chinese (CJK), Hindi (Indic), and English simultaneously without corruption or "tofu" boxes.

  KEY FEATURES:
  * Dynamic Page Width: Automatically calculates the required page width based on the number of 
    languages. If you have 30 languages, it creates a wide "panorama" PDF so columns don't collapse.
  * Smart Shaping: Automatically handles Arabic/Urdu connection logic (RTL).
  * Font Fallbacks: Detects missing fonts and safely falls back to avoid crashes.

  --------------------------------------------------------------------------------------------------
  2. INSTALLATION (PYTHON LIBRARIES)
  --------------------------------------------------------------------------------------------------
  Open your terminal/command prompt and run:
  
      pip install pandas openpyxl reportlab arabic-reshaper python-bidi

  * reportlab: The engine that draws the PDF.
  * arabic-reshaper: REQUIRED to fix Arabic letters (e.g., converts 'm k t b' -> 'mktb').
  * python-bidi: REQUIRED to handle Right-to-Left (RTL) text direction for Arabic/Hebrew/Urdu.

  --------------------------------------------------------------------------------------------------
  3. INPUT FILE REQUIREMENTS
  --------------------------------------------------------------------------------------------------
  This script expects a file named 'glossary.xlsx' in the same folder.
  This file is automatically created by running 'script_translate.py' first.

  --------------------------------------------------------------------------------------------------
  4. FONT SETUP (CRITICAL)
  --------------------------------------------------------------------------------------------------
  The PDF engine (ReportLab) requires PHYSICAL access to .ttf/.ttc files to embed them.
  If a font is missing, the script will crash or produce errors.

  [FOLDER STRUCTURE]
  Ensure your 'fonts' folder contains ALL of these files to support the 30-language list:

      /your_project/
        ├── get_fonts.py             # Stage 0: Fonts Downloader
        ├── script_translate.py      # Stage 1: Translator
        ├── script_glossary.py       # Stage 2: PDF Renderer (Glossary)
        ├── script_table.py          # Stage 2: PDF Renderer (Table)
        ├── english.xlsx             # Source Input
        ├── glossary.xlsx            # Intermediate Output
        └── fonts/
              │  # --- 1. CORE FONTS (Latin/Cyrillic & Headers) ---
              ├── NotoSansLiving-Regular.ttf      <-- Base text (English, French, Spanish, Turkish, etc.)
              ├── NotoSans-Bold.ttf               <-- REQUIRED for Headers/Titles in PDF generation
              │
              │  # --- 2. EAST ASIAN (CJK) ---
              ├── NotoSansCJK.ttc                 <-- "Super Font" for Chinese, Japanese, & Korean
              │                                       (Note: .ttc is a Collection file. Do not use .otf)
              │
              │  # --- 3. MIDDLE EASTERN (RTL) ---
              ├── NotoSansArabic-Regular.ttf      <-- Arabic, Persian, & Urdu (Fallback)
              ├── NotoNastaliqUrdu-Regular.ttf    <-- Urdu (Preferred "Cascading" style)
              │
              │  # --- 4. SOUTH ASIAN (Indic Scripts) ---
              ├── NotoSansDevanagari-Regular.ttf  <-- Hindi & Marathi
              ├── NotoSansBengali-Regular.ttf     <-- Bengali
              ├── NotoSansGujarati-Regular.ttf    <-- Gujarati
              ├── NotoSansTamil-Regular.ttf       <-- Tamil
              ├── NotoSansTelugu-Regular.ttf      <-- Telugu
              ├── NotoSansGurmukhi-Regular.ttf    <-- Western Punjabi (Google outputs Gurmukhi script)
              │
              │  # --- 5. SOUTHEAST ASIAN ---
              ├── NotoSansThai-Regular.ttf        <-- Thai
              ├── NotoSansJavanese-Regular.ttf    <-- Javanese

  [REQUIRED FONTS TO DOWNLOAD]
  To guarantee zero "Tofu" (☐☐☐) and perfect rendering in both Excel and PDF, you must 
  download the specific font files listed below.

  A. THE "CORE" FONTS (Latin, Cyrillic, Greek & Headers)
     * Filenames: "NotoSansLiving-Regular.ttf" AND "NotoSans-Bold.ttf"
     * Source:    https://github.com/notofonts/notofonts.github.io/tree/main/megamerge
     * Why:       
       1. "Regular" (Living): This specific "Mega-Merge" version covers ~80% of languages (English, 
          French, Russian, etc.) in a single file. It fixes rendering issues for Turkish (İ, ş) 
          and Vietnamese (stacked diacritics) that standard Arial often breaks.
       2. "Bold": MANDATORY for the PDF generator. Without 'NotoSans-Bold.ttf', section headers 
          (e.g., "CATEGORY") will fail to render, causing the script to crash or print blank headers.

  B. THE "CJK" SUPER-FONT (Chinese, Japanese, Korean)
     * Filename:  "NotoSerifCJK.ttc" (or NotoSansCJK.ttc)
     * Source:    https://github.com/notofonts/noto-cjk
     * Why:       
       1. Scale: CJK languages require >65,000 glyphs. Standard fonts do not contain them all.
       2. Efficiency: The ".ttc" (TrueType Collection) format bundles Simplified Chinese (SC), 
          Traditional Chinese (TC), Japanese (JP), and Korean (KR) into one efficient file.
       3. Compatibility: This script is tuned to detect the "TTC" collection. Using individual 
          ".otf" files may result in Excel failing to recognize the font family.

  C. MIDDLE EASTERN (Right-to-Left Scripts)
     * Filenames: 
       1. "NotoSansArabic-Regular.ttf" (Essential for Arabic, Persian, & Standard Urdu)
       2. "NotoNastaliqUrdu-Regular.ttf" (Recommended for Urdu aesthetics)
     * Source:    https://www.google.com/get/noto/
     * Why:       
       1. Shaping: Arabic letters change shape based on position (Start/Middle/End). Standard 
          fonts often break these "ligatures," leaving letters disconnected (e.g., م ك instead of مك).
       2. Style: Urdu users prefer "Nastaliq" (cascading style). If present, the script uses it; 
          otherwise, it safely falls back to the standard Naskh style.

  D. SOUTH ASIAN (Indic Scripts / Abugidas)
     * Filenames:
       - "NotoSansDevanagari-Regular.ttf" (Hindi, Marathi)
       - "NotoSansBengali-Regular.ttf"    (Bengali)
       - "NotoSansGujarati-Regular.ttf"   (Gujarati)
       - "NotoSansTamil-Regular.ttf"      (Tamil)
       - "NotoSansTelugu-Regular.ttf"     (Telugu)
       - "NotoSansGurmukhi-Regular.ttf"   (Western Punjabi)
     * Source:    https://github.com/notofonts/noto-fonts (Download the "Phase 3" zip)
     * Why:       
       1. Complex Layout: These scripts use engines where vowels "float" above, below, or wrap 
          around consonants.
       2. Rendering: Without these specific fonts, vowels will detach from their consonants and 
          render as dotted circles (◌) or meaningless boxes.

  E. SOUTHEAST ASIAN
     * Filenames: "NotoSansThai-Regular.ttf", "NotoSansJavanese-Regular.ttf"
     * Why:       Thai tone marks must stack vertically at precise heights. Javanese is a rare 
                  historical script often completely missing from standard Windows/Mac systems.

====================================================================================================
"""

import pandas as pd
import os
import sys
import re
import platform

# ==============================================================================
# REPORTLAB IMPORTS (The Engine)
# ==============================================================================
# We use 'Table' and 'TableStyle' for the grid layout.
# We use 'landscape' to orient the page horizontally by default.
from reportlab.lib.pagesizes import A4, landscape
from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
)
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from reportlab.lib.units import cm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfgen import canvas 

# ==============================================================================
# OPTIONAL IMPORTS (For Arabic/Urdu Shaping)
# ==============================================================================
# PDF generators do not natively support "Right-to-Left" (RTL) logic or Arabic 
# text shaping (connecting letters). We must use external libraries to pre-process
# the text before sending it to the PDF engine.
RTL_SUPPORT = False
try:
    import arabic_reshaper
    from bidi.algorithm import get_display
    RTL_SUPPORT = True
    print("[INFO] RTL Libraries found. Arabic/Urdu will be shaped correctly.")
except ImportError:
    print("WARNING: 'arabic-reshaper' or 'python-bidi' not found.")
    print("         Arabic/Urdu letters will be DISCONNECTED.")
    print("         To fix: pip install arabic-reshaper python-bidi")

# ==============================================================================
# SECTION A: GLOBAL CONFIGURATION
# ==============================================================================
# We use absolute paths to ensure reliability regardless of where the script is executed.
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
INPUT_FILE = os.path.join(BASE_DIR, "glossary.xlsx")
OUTPUT_FILE = os.path.join(BASE_DIR, "table.pdf")
FONTS_DIR = os.path.join(BASE_DIR, "fonts")

# Visual Styling Colors
HEADER_BG_COLOR = colors.darkblue       # Background for the top header row
HEADER_TEXT_COLOR = colors.whitesmoke   # Text color for the top header row
ROW_BG_EVEN = colors.whitesmoke         # Zebra striping: Light Grey
ROW_BG_ODD = colors.white               # Zebra striping: White
GRID_COLOR = colors.lightgrey           # Color of the table grid lines

# ==============================================================================
# SECTION B: FONT MAPPING CONFIGURATION
# ==============================================================================
# This dictionary is the "Brain" of the font selection engine. 
# It tells the script exactly which font file to use for which language.
#
# Structure:
#   "Internal_Language_ID": {
#       "search_terms": [List of keywords to find the file in ./fonts],
#       "family": "The Name to Register in ReportLab"
#   }

FONT_CONFIG = {
    # --- 1. GLOBAL DEFAULTS ---
    # Used for languages that use standard Latin characters (English, French, etc.)
    "Default": {
        "search_terms": ["notosansliving", "notosans-regular", "arial", "helvetica", "calibri", "segoeui"],
        "family": "NotoSans_Default"
    },
    "Bold": { 
        "search_terms": ["notosans-bold", "arial-bold", "helvetica-bold", "calibrib"],
        "family": "NotoSans_Bold"
    },

    # --- 2. WESTERN / EUROPEAN ---
    "French": { "search_terms": ["notosans-regular", "arial"], "family": "NotoSans_Default" },
    "Spanish": { "search_terms": ["notosans-regular", "arial"], "family": "NotoSans_Default" },
    "German": { "search_terms": ["notosans-regular", "arial"], "family": "NotoSans_Default" },
    "Italian": { "search_terms": ["notosans-regular", "arial"], "family": "NotoSans_Default" },
    "Portuguese": { "search_terms": ["notosans-regular", "arial"], "family": "NotoSans_Default" },
    "Turkish": { "search_terms": ["notosans-regular", "arial"], "family": "NotoSans_Default" },
    
    # --- 3. SPECIAL LATIN & CYRILLIC ---
    "Russian": { 
        "search_terms": ["notosanscyrillic", "notosans-regular", "arial", "segoeui"], 
        "family": "NotoSans_Default" 
    },
    "Vietnamese": { 
        "search_terms": ["notosansvietnamese", "notosans-regular", "arial", "segoeui"], 
        "family": "NotoSans_Default" 
    },
    "Hausa": { "search_terms": ["notosans-regular", "arial"], "family": "NotoSans_Default" },
    "Swahili": { "search_terms": ["notosans-regular", "arial"], "family": "NotoSans_Default" },
    "Indonesian": { "search_terms": ["notosansliving", "notosans-regular", "arial"], "family": "NotoSans_Default" },

    # --- 4. EAST ASIAN (CJK) ---
    # These require the massive .ttc collections.
    "Mandarin_Chinese": {
        "search_terms": ["notosanssc", "notosanscjksc", "simhei", "simkai", "arialuni", "dengxian", "notoserifcjk"],
        "family": "NotoSans_SC"
    },
    "Wu_Chinese": { 
        "search_terms": ["notosanssc", "notosanscjksc", "simhei", "arialuni"],
        "family": "NotoSans_SC"
    },
    "Yue_Chinese": { 
        "search_terms": ["notosanstc", "notosanscjktc", "microsoftjhenghei", "msjh", "mingliu", "pmingliu", "simhei"],
        "family": "NotoSans_TC"
    },
    "Japanese": {
        "search_terms": ["notosansjp", "notosanscjkjp", "msgothic", "meiryo", "arialuni"],
        "family": "NotoSans_JP"
    },
    "Korean": {
        "search_terms": ["notosanskr", "notosanscjkkr", "malgun", "gulim", "arialuni"],
        "family": "NotoSans_KR"
    },

    # --- 5. MIDDLE EASTERN (RTL) ---
    # These require shaping logic (see shape_text function below).
    "Arabic": { "search_terms": ["notosansarabic", "arial", "tahoma", "segoeui"], "family": "NotoSans_Arabic" },
    "Egyptian_Arabic": { "search_terms": ["notosansarabic", "arial"], "family": "NotoSans_Arabic" },
    "Standard_Arabic": { "search_terms": ["notosansarabic", "arial"], "family": "NotoSans_Arabic" },
    "Iranian_Persian": { "search_terms": ["notosansarabic", "arial"], "family": "NotoSans_Arabic" },
    "Urdu": { "search_terms": ["notosansarabic", "arial", "tahoma", "notonastaliqurdu"], "family": "NotoSans_Urdu" },
    
    # --- 6. SOUTH ASIAN (Indic) ---
    # Special handling for Western Punjabi to fallback to Gurmukhi if Google Translate returns incorrect script.
    "Western_Punjabi": { "search_terms": ["notosansarabic", "notosansgurmukhi"], "family": "NotoSans_Arabic" },
    "Gurmukhi_Fallback": { "search_terms": ["notosansgurmukhi", "raavi", "nirmala"], "family": "NotoSans_Gurmukhi" },
    
    "Hindi": { "search_terms": ["notosansdevanagari", "mangal", "nirmala", "aparajita"], "family": "NotoSans_Devanagari" },
    "Marathi": { "search_terms": ["notosansdevanagari", "mangal"], "family": "NotoSans_Devanagari" },
    "Bengali": { "search_terms": ["notosansbengali", "vrinda"], "family": "NotoSans_Bengali" },
    "Telugu": { "search_terms": ["notosanstelugu", "gautami"], "family": "NotoSans_Telugu" },
    "Tamil": { "search_terms": ["notosanstamil", "latha"], "family": "NotoSans_Tamil" },
    "Gujarati": { "search_terms": ["notosansgujarati", "shruti"], "family": "NotoSans_Gujarati" },

    # --- 7. SOUTHEAST ASIAN ---
    "Thai": { "search_terms": ["notosansthai", "leelawadee", "tahoma"], "family": "NotoSans_Thai" },
    "Javanese": { "search_terms": ["notosansjavanese", "notosans-regular", "javatext"], "family": "NotoSans_Javanese" },
}

# ==============================================================================
# SECTION C: ROBUST FONT ENGINE
# ==============================================================================
# This section handles the physical discovery and registration of fonts.
# It makes the script "portable" - it searches the folder rather than hardcoding paths.

FONT_PATH_CACHE = {} 
REGISTERED_FAMILIES = set()
WARNED_LANGUAGES = set()

def normalize_name(name):
    """
    Normalizes a filename to make fuzzy matching easier.
    Input: "01_NotoSans-Regular.ttf" -> Output: "notosans"
    """
    name = name.lower()
    name = os.path.splitext(name)[0]
    name = re.sub(r'[\s\-_]', '', name)
    name = name.replace("regular", "")
    return name

def scan_directory(base_path, is_system=False):
    """
    Recursively scans a folder for .ttf, .otf, and .ttc files.
    Populates the global FONT_PATH_CACHE.
    """
    if not os.path.exists(base_path):
        return 0
    
    count = 0
    if is_system:
        try:
            files = os.listdir(base_path)
            walker = [(base_path, [], files)]
        except:
            return 0
    else:
        walker = os.walk(base_path)

    for root, dirs, files in walker:
        for f in files:
            f_lower = f.lower()
            if not f_lower.endswith(('.ttf', '.otf', '.ttc')):
                continue
            # Block Variable Fonts (ReportLab cannot handle them and will crash)
            if "-vf" in f_lower or "variable" in f_lower or "wght" in f_lower:
                continue

            full_path = os.path.join(root, f)
            norm_key = normalize_name(f)
            
            if norm_key not in FONT_PATH_CACHE:
                FONT_PATH_CACHE[norm_key] = []
            
            # Prioritize TTC files (collections often contain the needed CJK fonts)
            if f_lower.endswith('.ttc'):
                FONT_PATH_CACHE[norm_key].insert(0, full_path)
            else:
                FONT_PATH_CACHE[norm_key].append(full_path)
            count += 1
    return count

def scan_all_fonts():
    """
    Orchestrates the font scanning process (Local Folder + System Folder).
    """
    print(f"--- [System] Scanning Fonts... ---")
    local_count = scan_directory(FONTS_DIR)
    print(f"  > Local './fonts': Found {local_count} SAFE fonts (VF Blocked).")
    
    sys_count = 0
    if platform.system() == "Windows":
        sys_font_dir = "C:\\Windows\\Fonts"
        print(f"  > Scanning Windows System Fonts: {sys_font_dir}...")
        try:
            sys_count = scan_directory(sys_font_dir, is_system=True)
            print(f"  > Windows System: Found {sys_count} SAFE fonts.")
        except Exception as e:
            print(f"  > [Warning] Could not scan Windows fonts: {e}")

    print(f"--- Scan complete. Total Index: {local_count + sys_count} fonts. ---\n")

def get_font_candidates(config_entry):
    """
    Retrieves all potential file paths for a specific language config.
    """
    search_terms = config_entry.get('search_terms', [])
    candidates = []
    
    for term in search_terms:
        term_norm = normalize_name(term)
        if term_norm in FONT_PATH_CACHE:
            candidates.extend(FONT_PATH_CACHE[term_norm])
        # Fuzzy match
        for cached_key, paths in FONT_PATH_CACHE.items():
            if term_norm in cached_key:
                candidates.extend(paths)
    
    # Deduplicate
    seen = set()
    unique_candidates = []
    for c in candidates:
        if c not in seen:
            unique_candidates.append(c)
            seen.add(c)
    return unique_candidates

def register_font_for_language(language_name):
    """
    Registers the best available font for a given language with ReportLab.
    Returns the internal Font Name to be used in the PDF.
    
    Logic:
    1. Check config.
    2. Find file candidates on disk.
    3. Attempt to register (handles .ttc index iteration).
    4. Fallback to Helvetica if no font found.
    """
    # Determine which config to use
    if language_name in FONT_CONFIG:
        config = FONT_CONFIG[language_name]
    elif language_name == "Bold":
        config = FONT_CONFIG["Bold"]
    else:
        # Fallback search
        config = FONT_CONFIG.get("Default")
        lang_search = language_name.replace(" ", "_")
        for key, val in FONT_CONFIG.items():
            if key in lang_search:
                config = val
                break
    
    family_name = config['family']

    # Optimization: Don't re-register if we already did it
    if family_name in REGISTERED_FAMILIES:
        return family_name

    candidates = get_font_candidates(config)
    
    if not candidates:
        if language_name not in ["Default", "English"] and language_name not in WARNED_LANGUAGES:
            print(f"[WARNING] No font found for '{language_name}'. Using Helvetica.")
            WARNED_LANGUAGES.add(language_name)
        return "Helvetica"

    success = False
    
    # Try all candidates
    for font_path in candidates:
        is_ttc = font_path.lower().endswith('.ttc')
        # If TTC, try indices 0 to 4. If TTF, just index 0.
        max_indices = 5 if is_ttc else 1 
        
        for i in range(max_indices):
            try:
                if is_ttc:
                    # Noto CJK often puts the specific language version in different indices
                    font_obj = TTFont(family_name, font_path, subfontIndex=i)
                else:
                    font_obj = TTFont(family_name, font_path)
                
                pdfmetrics.registerFont(font_obj)
                REGISTERED_FAMILIES.add(family_name)
                success = True
                
                if language_name == "Bold" or language_name not in ["Default", "English"]:
                    idx_str = f" (Index {i})" if is_ttc else ""
                    print(f"  > Registered '{language_name}' using: {os.path.basename(font_path)}{idx_str}")
                break 
            except Exception:
                continue # Try next index or next file
        
        if success:
            break 
            
    if not success:
        if language_name not in WARNED_LANGUAGES:
            print(f"[ERROR] Failed to load fonts for '{language_name}'. Fallback to Helvetica.")
            WARNED_LANGUAGES.add(language_name)
        return "Helvetica"
    
    return family_name

# ==============================================================================
# SECTION D: TEXT PROCESSING (SHAPING & SCRIPT DETECTION)
# ==============================================================================

def is_gurmukhi(text):
    """Detects if text contains Gurmukhi characters (common for Google 'pa' output)."""
    for char in text:
        if 0x0A00 <= ord(char) <= 0x0A7F:
            return True
    return False

def is_latin_only(text):
    """Detects if text is purely Latin (A-Z), numbers, or basic punctuation."""
    clean = re.sub(r'[ \.,;:\(\)\-\d]', '', text)
    if not clean: return True
    # Check if remaining are Latin
    return all(ord(c) < 128 or (0x00C0 <= ord(c) <= 0x00FF) for c in clean)

def shape_text(text, language_name):
    """
    Applies RTL shaping if libraries are present.
    Crucial for Arabic/Urdu to connect letters properly.
    Includes fallback for different library versions.
    """
    if not text: return ""
    
    # List of RTL languages
    rtl_langs = ["Arabic", "Urdu", "Persian", "Western_Punjabi", "Pashto", "Egyptian_Arabic", "Standard_Arabic"]
    is_rtl = any(lang in language_name for lang in rtl_langs)
    
    if is_rtl and RTL_SUPPORT:
        try:
            # 1. Try Advanced Config (Works with newer arabic-reshaper)
            # This config enforces ligatures and proper connection logic.
            config = {
                'delete_harakat': False, 
                'support_ligatures': True,
                'use_unshaped_instead_of_isolated': True 
            }
            if "Urdu" in language_name or "Punjabi" in language_name:
                config['language'] = 'Urdu'
                
            reshaped_text = arabic_reshaper.reshape(text, configuration=config)
            return get_display(reshaped_text)
            
        except TypeError:
            # 2. Fallback for older versions (v2.x) that don't support 'configuration'
            # The 'configuration' kwarg causes a TypeError in old versions
            try:
                reshaped_text = arabic_reshaper.reshape(text)
                return get_display(reshaped_text)
            except Exception as e:
                print(f"[WARN] Shaping fallback failed for {language_name}: {e}")
                return text
                
        except Exception as e:
            print(f"[WARN] Shaping failed for {language_name}: {e}")
            return text
            
    return text

# ==============================================================================
# SECTION E: MAIN PDF GENERATION
# ==============================================================================

def generate_pdf():
    print("\n========================================================")
    print("   ROBUST MULTILINGUAL PDF TABLE GENERATOR")
    print("========================================================")
    
    # 1. Prepare Fonts
    scan_all_fonts()

    # 2. Load Data
    if not os.path.exists(INPUT_FILE):
        print(f"[ERROR] {INPUT_FILE} not found.")
        return

    print(f"Reading data from {INPUT_FILE}...")
    try:
        df = pd.read_excel(INPUT_FILE).fillna('')
    except Exception as e:
        print(f"[CRITICAL ERROR] Could not open Excel file: {e}")
        return

    # Identify language columns (Words Only, Exclude Descriptions)
    word_cols = [c for c in df.columns if c.endswith('_word')]
    languages = [c.replace('_word', '') for c in word_cols]
    
    # Sort English to top/left for consistency
    if 'English' in languages:
        languages.remove('English')
        languages = ['English'] + languages

    print(f"Detected Languages: {len(languages)}")

    if 'Category' in df.columns:
        df.sort_values(by=['Category', 'English_word'], inplace=True)

    # 3. Dynamic Page Layout Calculation
    #    CRITICAL: Avoids squashing columns by extending page width 
    #    if there are many languages.
    COL_WIDTH = 3.5 * cm  # Minimum readable width per column
    REQUIRED_WIDTH = (len(languages) * COL_WIDTH) + (2 * cm) # Data + Margins
    
    # Use standard A4 height (21cm) for rows
    # Standard A4 Landscape width is ~29.7cm.
    if REQUIRED_WIDTH < 29.7 * cm:
        PAGE_WIDTH = 29.7 * cm  # Minimum Standard A4
    else:
        PAGE_WIDTH = REQUIRED_WIDTH
        print(f"[INFO] Page width extended to {int(PAGE_WIDTH/cm)}cm to fit {len(languages)} languages.")

    # 4. Document Setup
    doc = SimpleDocTemplate(OUTPUT_FILE, pagesize=(PAGE_WIDTH, 21*cm),
                            rightMargin=1.0*cm, leftMargin=1.0*cm,
                            topMargin=1.0*cm, bottomMargin=1.0*cm)
    
    styles = getSampleStyleSheet()
    
    # Register Base Fonts (Title and Default)
    title_font = register_font_for_language("Bold")
    if title_font == "Helvetica": title_font = "Helvetica-Bold"
    default_font = register_font_for_language("Default")

    # Define Styles
    style_doc_title = ParagraphStyle('MainTitle', parent=styles['Heading1'], fontName=title_font, fontSize=20, alignment=1, spaceAfter=20, textColor=HEADER_BG_COLOR)
    style_header = ParagraphStyle('Header', parent=styles['Normal'], fontName=title_font, fontSize=10, textColor=HEADER_TEXT_COLOR, alignment=1)
    style_cell = ParagraphStyle('Cell', parent=styles['Normal'], fontSize=9, leading=11)

    story = [] 
    story.append(Paragraph("Multilingual Vocabulary Table", style_doc_title))
    
    print("Generating Table content...")
    
    # 5. Build Table Data Structure
    #    A. Header Row
    header_row = []
    for lang in languages:
        clean_name = lang.replace('_', ' ').replace('Standard', '')
        header_row.append(Paragraph(f"<b>{clean_name}</b>", style_header))
    
    table_data = [header_row]

    #    B. Data Rows
    for _, row in df.iterrows():
        current_row_cells = []
        
        for lang in languages:
            raw_word = str(row.get(f'{lang}_word', '')).strip()
            
            # Empty Cell Handling
            if not raw_word:
                # Add a grey dash for empty cells
                html = f"<font color='grey'>-</font>"
            else:
                # --- DYNAMIC FONT SELECTION ---
                current_font = register_font_for_language(lang)
                
                # FIX: Check if "Western Punjabi" returned Gurmukhi script
                if "Punjabi" in lang and is_gurmukhi(raw_word):
                    current_font = register_font_for_language("Gurmukhi_Fallback")
                    display_word = raw_word 
                # FIX: Check if Javanese returned Latin script
                elif "Javanese" in lang and is_latin_only(raw_word):
                    current_font = default_font
                    display_word = raw_word
                else:
                    # Standard processing (RTL shaping if needed)
                    display_word = shape_text(raw_word, lang)
                
                # HTML content for the cell
                html = f"<font face='{current_font}'>{display_word}</font>"
            
            current_row_cells.append(Paragraph(html, style_cell))
        
        table_data.append(current_row_cells)
        
    # 6. Create Table Object and Apply Styles
    table = Table(table_data, colWidths=[COL_WIDTH] * len(languages), repeatRows=1)
    
    tbl_style = [
        ('BACKGROUND', (0, 0), (-1, 0), HEADER_BG_COLOR),
        ('TEXTCOLOR', (0, 0), (-1, 0), HEADER_TEXT_COLOR),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ('GRID', (0, 0), (-1, -1), 0.5, GRID_COLOR),
        ('FONTNAME', (0, 0), (-1, 0), title_font),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
        ('TOPPADDING', (0, 0), (-1, 0), 8),
    ]

    # Zebra striping (Alternating row colors)
    for i in range(1, len(table_data)):
        bg_color = ROW_BG_EVEN if i % 2 == 0 else ROW_BG_ODD
        tbl_style.append(('BACKGROUND', (0, i), (-1, i), bg_color))

    table.setStyle(TableStyle(tbl_style))
    story.append(table)
        
    print(f"Writing PDF to disk: {OUTPUT_FILE}...")
    try:
        doc.build(story)
        print("\nSUCCESS! Table PDF Generated successfully.")
    except Exception as e:
        print(f"\n[ERROR] Failed to build PDF: {e}")

if __name__ == "__main__":
    generate_pdf()